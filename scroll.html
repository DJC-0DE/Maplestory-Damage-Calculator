<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapleStory Scroll Optimizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #34495e;
        }
        input, button {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .results {
            margin-top: 20px;
        }
        .strategy {
            background: #ecf0f1;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .strategy.best {
            border-left-color: #2ecc71;
            background: #d5f4e6;
        }
        .strategy h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .metric {
            background: white;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .metric-value {
            font-size: 20px;
            font-weight: bold;
            color: #3498db;
        }
        .metric-label {
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 5px;
        }
        .progress {
            width: 100%;
            height: 4px;
            background: #ecf0f1;
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: #3498db;
            transition: width 0.3s;
        }
        .scroll-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .scroll-card {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #3498db;
        }
        .scroll-card h4 {
            margin: 0 0 8px 0;
            color: #2c3e50;
            font-size: 14px;
        }
        .scroll-card .stat {
            font-size: 12px;
            color: #7f8c8d;
            margin: 2px 0;
        }
        .info-box {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 12px;
            margin: 15px 0;
            border-radius: 4px;
            font-size: 14px;
            color: #2c3e50;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        th {
            background: #34495e;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background: #2c3e50;
        }
        th.sorted-asc::after {
            content: ' ▲';
            font-size: 10px;
        }
        th.sorted-desc::after {
            content: ' ▼';
            font-size: 10px;
        }
        td {
            padding: 10px 12px;
            border-bottom: 1px solid #ecf0f1;
            font-size: 13px;
        }
        tr:hover {
            background: #f8f9fa;
        }
        tr.best-row {
            background: #d5f4e6;
            font-weight: bold;
        }
        tr.best-row:hover {
            background: #c8edd9;
        }
        .filter-container {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
        }
        .filter-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        .filter-row select, .filter-row input {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        .filter-row input[type="number"] {
            width: 100px;
        }
        .filter-row button {
            padding: 6px 12px;
            font-size: 13px;
        }
        .filter-label {
            font-weight: bold;
            font-size: 13px;
            color: #34495e;
        }
    </style>
</head>
<body>
    <h1>MapleStory Scroll Optimizer</h1>

    <div class="container">
        <h2>Scroll Information</h2>
        <div class="info-box">
            <strong>Mechanics:</strong> 10 scroll slots per item. Slot 5 grants +10% success rate, Slot 10 grants +20% success rate.
            You have a permanent +2% success bonus. Failed scrolls brick that slot (no bonuses).
            Resetting costs 50 spell trace and reverts all slots back to unenhanced.
        </div>
        <div class="scroll-info">
            <div class="scroll-card">
                <h4>70% Level 35 Scroll</h4>
                <div class="stat">Base Success: 70% → 72% (with bonus)</div>
                <div class="stat">Cost: 150 spell trace</div>
                <div class="stat">Attack: +50</div>
            </div>
            <div class="scroll-card">
                <h4>30% Level 35 Scroll</h4>
                <div class="stat">Base Success: 30% → 32% (with bonus)</div>
                <div class="stat">Cost: 150 spell trace</div>
                <div class="stat">Attack: +90</div>
            </div>
            <div class="scroll-card">
                <h4>70% Level 65 Scroll</h4>
                <div class="stat">Base Success: 70% → 72% (with bonus)</div>
                <div class="stat">Cost: 250 spell trace</div>
                <div class="stat">Attack: +100</div>
            </div>
            <div class="scroll-card">
                <h4>30% Level 65 Scroll</h4>
                <div class="stat">Base Success: 30% → 32% (with bonus)</div>
                <div class="stat">Cost: 300 spell trace</div>
                <div class="stat">Attack: +200, Damage Amp: +0.1%</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Simulation Settings</h2>
        <div class="controls">
            <div class="control-group">
                <label for="spellTraceBudget">Spell Trace Budget:</label>
                <input type="number" id="spellTraceBudget" value="7000" min="500" max="50000" step="100">
            </div>
            <div class="control-group">
                <label for="simulations">Number of Simulations:</label>
                <input type="number" id="simulations" value="500" min="100" max="10000" step="100">
            </div>
        </div>
        <button id="runSimulation" onclick="runSimulation()">Run Simulation</button>
        <div id="progressContainer" style="display: none;">
            <div class="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <p id="progressText" style="text-align: center; color: #7f8c8d;"></p>
        </div>
    </div>

    <div class="container results" id="results" style="display: none;">
        <h2>Strategy Comparison Results</h2>
        <div id="strategyResults"></div>
    </div>

    <script>
        // Scroll definitions
        const SCROLLS = {
            'L35_70': { name: '70% Level 35', baseSuccess: 0.70, cost: 150, attack: 50, damageAmp: 0 },
            'L35_30': { name: '30% Level 35', baseSuccess: 0.30, cost: 150, attack: 90, damageAmp: 0 },
            'L65_70': { name: '70% Level 65', baseSuccess: 0.70, cost: 250, attack: 100, damageAmp: 0 },
            'L65_30': { name: '30% Level 65', baseSuccess: 0.30, cost: 300, attack: 200, damageAmp: 0.1 }
        };

        const GLOBAL_SUCCESS_BONUS = 0.02;
        const BONUS_AT_SLOT_5 = 0.10;
        const BONUS_AT_SLOT_10 = 0.20;
        const RESET_COST = 50;
        const NUM_SLOTS = 10;

        // Calculate success rate for a scroll at a specific slot
        function getSuccessRate(scroll, slotNumber) {
            let rate = scroll.baseSuccess + GLOBAL_SUCCESS_BONUS;
            if (slotNumber === 5) rate += BONUS_AT_SLOT_5;
            if (slotNumber === 10) rate += BONUS_AT_SLOT_10;
            return Math.min(rate, 1.0); // Cap at 100%
        }

        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                spellTraceBudget: document.getElementById('spellTraceBudget').value,
                simulations: document.getElementById('simulations').value
            };
            localStorage.setItem('maplestory_scroll_settings', JSON.stringify(settings));
        }

        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('maplestory_scroll_settings');
            if (!saved) return false;
            try {
                const settings = JSON.parse(saved);
                if (settings.spellTraceBudget) document.getElementById('spellTraceBudget').value = settings.spellTraceBudget;
                if (settings.simulations) document.getElementById('simulations').value = settings.simulations;
                return true;
            } catch (e) {
                console.error('Error loading settings:', e);
                return false;
            }
        }

        // Auto-save settings when they change
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            ['spellTraceBudget', 'simulations'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', saveSettings);
                }
            });
        });

        // Attempt one complete scroll run (all 10 slots)
        function attemptScrolling(strategy, budget, traceUsed) {
            let totalAttack = 0;
            let totalDamageAmp = 0;
            let successfulSlots = 0;
            let failedSlots = 0;
            let attemptCost = 0;
            const slotResults = [];

            for (let slot = 1; slot <= NUM_SLOTS; slot++) {
                const scrollType = strategy.selectScroll(slot, successfulSlots, failedSlots, traceUsed + attemptCost, budget);
                const scroll = SCROLLS[scrollType];

                // Check if we can afford this scroll
                if (traceUsed + attemptCost + scroll.cost > budget) {
                    // Out of budget mid-attempt, mark remaining slots as unfunded
                    for (let s = slot; s <= NUM_SLOTS; s++) {
                        slotResults.push({ slot: s, success: false, unfunded: true });
                    }
                    break;
                }

                attemptCost += scroll.cost;
                const successRate = getSuccessRate(scroll, slot);
                const success = Math.random() < successRate;

                slotResults.push({
                    slot,
                    scrollType,
                    success,
                    attack: success ? scroll.attack : 0,
                    damageAmp: success ? scroll.damageAmp : 0,
                    successRate: successRate * 100,
                    unfunded: false
                });

                if (success) {
                    totalAttack += scroll.attack;
                    totalDamageAmp += scroll.damageAmp;
                    successfulSlots++;
                } else {
                    failedSlots++;
                }
            }

            return {
                totalAttack,
                totalDamageAmp,
                successfulSlots,
                failedSlots,
                attemptCost,
                slotResults
            };
        }

        // Simulate with reset strategy
        function simulateWithResets(strategy, budget) {
            let traceUsed = 0;
            let resetCount = 0;
            let finalResult = null;
            let attemptCount = 0;

            while (traceUsed < budget) {
                attemptCount++;
                const result = attemptScrolling(strategy, budget, traceUsed);

                // Check if we ran out of budget during attempt
                if (traceUsed + result.attemptCost > budget) {
                    // Can't complete this attempt, return previous result or empty
                    if (finalResult) {
                        return { ...finalResult, resetCount, attemptCount };
                    } else {
                        return {
                            totalAttack: 0,
                            totalDamageAmp: 0,
                            successfulSlots: 0,
                            failedSlots: NUM_SLOTS,
                            traceUsed: 0,
                            resetCount: 0,
                            attemptCount: 0,
                            slotResults: []
                        };
                    }
                }

                traceUsed += result.attemptCost;
                finalResult = { ...result, traceUsed };

                // Strategy decides whether to reset
                const shouldReset = strategy.shouldReset(result, traceUsed, budget);

                if (!shouldReset) {
                    // Accept this result
                    break;
                }

                // Try to reset
                if (traceUsed + RESET_COST <= budget) {
                    traceUsed += RESET_COST;
                    resetCount++;
                } else {
                    // Can't afford reset, must accept current result
                    break;
                }
            }

            return { ...finalResult, resetCount, attemptCount };
        }

        // Helper function to create strategy variations
        function createStrategyVariations() {
            const strategies = [];

            // Scroll selection patterns
            const patterns = [
                {
                    id: 'L35_70',
                    name: '70% L35',
                    selectScroll: () => 'L35_70',
                    thresholds: [10, 9, 8, 7, 6]
                },
                {
                    id: 'L65_70',
                    name: '70% L65',
                    selectScroll: () => 'L65_70',
                    thresholds: [10, 9, 8, 7, 6]
                },
                {
                    id: 'L65_30',
                    name: '30% L65',
                    selectScroll: () => 'L65_30',
                    thresholds: [10, 9, 8, 7, 6, 5, 4]
                },
                {
                    id: 'bonus_both',
                    name: 'Bonus 5&10',
                    selectScroll: (slot) => (slot === 5 || slot === 10) ? 'L65_30' : 'L65_70',
                    thresholds: [10, 9, 8, 7, 6]
                },
                {
                    id: 'bonus_10',
                    name: 'Bonus 10 Only',
                    selectScroll: (slot) => (slot === 10) ? 'L65_30' : 'L65_70',
                    thresholds: [10, 9, 8, 7, 6]
                }
            ];

            // Generate threshold variations for each pattern
            for (const pattern of patterns) {
                for (const threshold of pattern.thresholds) {
                    strategies.push({
                        id: `${pattern.id}_reset_${threshold}`,
                        name: `${pattern.name} - Reset <${threshold}`,
                        description: `${pattern.name} scrolls. Reset if fewer than ${threshold} slots succeed.`,
                        selectScroll: pattern.selectScroll,
                        shouldReset: (result) => result.successfulSlots < threshold
                    });
                }
            }

            // Add unique strategies
            strategies.push({
                id: 'reset_early_fail',
                name: '70% L65 - Early Fail Reset',
                description: '70% L65 scrolls. Reset if any of slots 1-3 fail.',
                selectScroll: () => 'L65_70',
                shouldReset: (result) => {
                    for (let i = 0; i < 3 && i < result.slotResults.length; i++) {
                        if (!result.slotResults[i].success && !result.slotResults[i].unfunded) {
                            return true;
                        }
                    }
                    return false;
                }
            });

            strategies.push({
                id: 'reset_smart_slot10',
                name: '70% L65 - Slot 10 Priority',
                description: '70% L65 scrolls. Reset if <6 success OR slot 10 fails.',
                selectScroll: () => 'L65_70',
                shouldReset: (result) => {
                    if (result.successfulSlots < 6) return true;
                    const slot10 = result.slotResults.find(s => s.slot === 10);
                    if (slot10 && !slot10.success && !slot10.unfunded) return true;
                    return false;
                }
            });

            strategies.push({
                id: 'damage_amp_hunter',
                name: '30% L65 - Damage Amp Hunter',
                description: '30% L65 scrolls. Reset if damage amp < 0.5%.',
                selectScroll: () => 'L65_30',
                shouldReset: (result) => result.totalDamageAmp < 0.5
            });

            strategies.push({
                id: 'progressive_aggressive',
                name: 'Progressive - Start Aggressive',
                description: 'Start 30% L65, switch to 70% L35 after first fail. Reset if <7 success.',
                selectScroll: (slot, successfulSlots, failedSlots) => {
                    return failedSlots === 0 ? 'L65_30' : 'L35_70';
                },
                shouldReset: (result) => result.successfulSlots < 7
            });

            return strategies;
        }

        // Strategy definitions
        const STRATEGIES = createStrategyVariations();

        // Run full simulation
        async function runSimulation() {
            saveSettings();

            const budget = parseInt(document.getElementById('spellTraceBudget').value);
            const numSimulations = parseInt(document.getElementById('simulations').value);

            console.log(`Starting: ${numSimulations} simulations, ${budget} spell trace budget`);

            const button = document.getElementById('runSimulation');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');

            button.disabled = true;
            progressContainer.style.display = 'block';

            const results = {};

            for (const strategy of STRATEGIES) {
                results[strategy.id] = {
                    strategy,
                    attacks: [],
                    damageAmps: [],
                    successCounts: [],
                    resetCounts: [],
                    traceUsed: [],
                    avgAttack: 0,
                    avgDamageAmp: 0,
                    avgSuccess: 0,
                    avgResets: 0,
                    avgTraceUsed: 0,
                    exampleResult: null
                };
            }

            // Run simulations
            for (let sim = 0; sim < numSimulations; sim++) {
                if (sim % 50 === 0) {
                    const progress = (sim / numSimulations) * 100;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `${sim} / ${numSimulations}`;
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                for (const strategy of STRATEGIES) {
                    const result = simulateWithResets(strategy, budget);

                    const data = results[strategy.id];
                    data.attacks.push(result.totalAttack);
                    data.damageAmps.push(result.totalDamageAmp);
                    data.successCounts.push(result.successfulSlots);
                    data.resetCounts.push(result.resetCount);
                    data.traceUsed.push(result.traceUsed);

                    // Store last result as example
                    if (sim === numSimulations - 1) {
                        data.exampleResult = result;
                    }
                }
            }

            // Calculate averages
            for (const strategyId in results) {
                const data = results[strategyId];
                data.avgAttack = data.attacks.reduce((a, b) => a + b, 0) / numSimulations;
                data.avgDamageAmp = data.damageAmps.reduce((a, b) => a + b, 0) / numSimulations;
                data.avgSuccess = data.successCounts.reduce((a, b) => a + b, 0) / numSimulations;
                data.avgResets = data.resetCounts.reduce((a, b) => a + b, 0) / numSimulations;
                data.avgTraceUsed = data.traceUsed.reduce((a, b) => a + b, 0) / numSimulations;
            }

            displayResults(results, budget, numSimulations);

            button.disabled = false;
            progressContainer.style.display = 'none';
        }

        function displayResults(results, budget, numSimulations) {
            const container = document.getElementById('strategyResults');
            const resultsDiv = document.getElementById('results');

            resultsDiv.style.display = 'block';
            container.innerHTML = '';

            // Find best strategy by average attack
            let bestStrategy = null;
            let bestAvgAttack = -Infinity;

            for (const strategyId in results) {
                if (results[strategyId].avgAttack > bestAvgAttack) {
                    bestAvgAttack = results[strategyId].avgAttack;
                    bestStrategy = strategyId;
                }
            }

            // Create summary table with filters
            let tableHTML = `
                <h3>Strategy Comparison Summary (Click headers to sort)</h3>
                <div class="filter-container">
                    <div class="filter-row">
                        <span class="filter-label">Filter:</span>
                        <select id="filterColumn">
                            <option value="1">Avg Attack</option>
                            <option value="2">Avg Damage Amp</option>
                            <option value="3">Avg Success</option>
                            <option value="4">Avg Resets</option>
                            <option value="5">Avg Trace Used</option>
                            <option value="6">ATK/Trace</option>
                        </select>
                        <select id="filterOperator">
                            <option value=">">&gt; (greater than)</option>
                            <option value=">=">&gt;= (greater or equal)</option>
                            <option value="<">&lt; (less than)</option>
                            <option value="<=">&lt;= (less or equal)</option>
                            <option value="==">= (equal)</option>
                        </select>
                        <input type="number" id="filterValue" placeholder="Value" step="0.1">
                        <button onclick="applyTableFilter()">Apply Filter</button>
                        <button onclick="clearTableFilter()">Clear Filter</button>
                        <span id="filterStatus" style="color: #7f8c8d; font-size: 12px; margin-left: 10px;"></span>
                    </div>
                </div>
                <table id="resultsTable">
                    <thead>
                        <tr>
                            <th data-col="0" data-type="string">Strategy</th>
                            <th data-col="1" data-type="number" class="sorted-desc">Avg Attack</th>
                            <th data-col="2" data-type="number">Avg Damage Amp</th>
                            <th data-col="3" data-type="number">Avg Success</th>
                            <th data-col="4" data-type="number">Avg Resets</th>
                            <th data-col="5" data-type="number">Avg Trace Used</th>
                            <th data-col="6" data-type="number">ATK/Trace</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
            `;

            // Sort strategies by average attack (descending) - initial sort
            const sortedStrategies = Object.entries(results).sort((a, b) => b[1].avgAttack - a[1].avgAttack);

            for (const [strategyId, data] of sortedStrategies) {
                const isBest = strategyId === bestStrategy;
                const efficiency = data.avgTraceUsed > 0 ? (data.avgAttack / data.avgTraceUsed) : 0;
                const rowClass = isBest ? 'best-row' : '';

                tableHTML += `
                    <tr class="${rowClass}">
                        <td data-value="${data.strategy.name}">${data.strategy.name}${isBest ? ' ⭐' : ''}</td>
                        <td data-value="${data.avgAttack}">${data.avgAttack.toFixed(1)}</td>
                        <td data-value="${data.avgDamageAmp}">${data.avgDamageAmp.toFixed(2)}%</td>
                        <td data-value="${data.avgSuccess}">${data.avgSuccess.toFixed(1)}</td>
                        <td data-value="${data.avgResets}">${data.avgResets.toFixed(1)}</td>
                        <td data-value="${data.avgTraceUsed}">${data.avgTraceUsed.toFixed(0)}</td>
                        <td data-value="${efficiency}">${efficiency.toFixed(3)}</td>
                    </tr>
                `;
            }

            tableHTML += '</tbody></table>';
            container.innerHTML = tableHTML;

            // Add detailed breakdown header using DOM method to avoid destroying event listeners
            const breakdownHeader = document.createElement('h3');
            breakdownHeader.style.marginTop = '30px';
            breakdownHeader.textContent = 'Detailed Strategy Breakdown';
            container.appendChild(breakdownHeader);

            // Add table sorting functionality
            const table = document.getElementById('resultsTable');
            const headers = table.querySelectorAll('th');
            let currentSort = { col: 1, asc: false }; // Default sort by Avg Attack descending

            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const col = parseInt(this.dataset.col);
                    const type = this.dataset.type;
                    const tbody = document.getElementById('resultsTableBody');
                    const rows = Array.from(tbody.querySelectorAll('tr'));

                    // Toggle sort direction if same column, otherwise default to descending
                    const asc = currentSort.col === col ? !currentSort.asc : false;
                    currentSort = { col, asc };

                    // Sort rows
                    rows.sort((a, b) => {
                        const aVal = a.children[col].dataset.value;
                        const bVal = b.children[col].dataset.value;

                        let comparison = 0;
                        if (type === 'number') {
                            comparison = parseFloat(aVal) - parseFloat(bVal);
                        } else {
                            comparison = aVal.localeCompare(bVal);
                        }

                        return asc ? comparison : -comparison;
                    });

                    // Update table
                    rows.forEach(row => tbody.appendChild(row));

                    // Update header indicators
                    headers.forEach(h => {
                        h.classList.remove('sorted-asc', 'sorted-desc');
                    });
                    this.classList.add(asc ? 'sorted-asc' : 'sorted-desc');
                });
            });

            // Filter functions
            window.applyTableFilter = function() {
                const column = parseInt(document.getElementById('filterColumn').value);
                const operator = document.getElementById('filterOperator').value;
                const value = parseFloat(document.getElementById('filterValue').value);

                if (isNaN(value)) {
                    document.getElementById('filterStatus').textContent = 'Please enter a valid number';
                    return;
                }

                const tbody = document.getElementById('resultsTableBody');
                const rows = tbody.querySelectorAll('tr');
                let hiddenCount = 0;

                rows.forEach(row => {
                    const cellValue = parseFloat(row.children[column].dataset.value);
                    let show = false;

                    switch(operator) {
                        case '>': show = cellValue > value; break;
                        case '>=': show = cellValue >= value; break;
                        case '<': show = cellValue < value; break;
                        case '<=': show = cellValue <= value; break;
                        case '==': show = Math.abs(cellValue - value) < 0.01; break;
                    }

                    if (show) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                        hiddenCount++;
                    }
                });

                const columnName = document.getElementById('filterColumn').options[document.getElementById('filterColumn').selectedIndex].text;
                document.getElementById('filterStatus').textContent =
                    `Showing ${rows.length - hiddenCount} of ${rows.length} strategies (${columnName} ${operator} ${value})`;
            };

            window.clearTableFilter = function() {
                const tbody = document.getElementById('resultsTableBody');
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => row.style.display = '');
                document.getElementById('filterValue').value = '';
                document.getElementById('filterStatus').textContent = '';
            };

            // Display each strategy
            for (const strategyId in results) {
                const data = results[strategyId];
                const strategy = data.strategy;
                const isBest = strategyId === bestStrategy;

                // Calculate percentiles for attack
                const sortedAttacks = [...data.attacks].sort((a, b) => a - b);
                const p10 = sortedAttacks[Math.floor(sortedAttacks.length * 0.10)];
                const p50 = sortedAttacks[Math.floor(sortedAttacks.length * 0.50)];
                const p90 = sortedAttacks[Math.floor(sortedAttacks.length * 0.90)];

                const efficiency = data.avgTraceUsed > 0 ? (data.avgAttack / data.avgTraceUsed) : 0;

                const strategyDiv = document.createElement('div');
                strategyDiv.className = 'strategy' + (isBest ? ' best' : '');

                // Build slot results display
                let slotsHTML = '';
                if (data.exampleResult && data.exampleResult.slotResults) {
                    slotsHTML = '<div style="margin-top: 10px;"><strong>Example Run (Last Simulation):</strong><div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 8px;">';
                    data.exampleResult.slotResults.forEach(slot => {
                        const bgColor = slot.unfunded ? '#bdc3c7' : (slot.success ? '#d5f4e6' : '#f8d7da');
                        const status = slot.unfunded ? 'No Budget' : (slot.success ? '✓' : '✗');
                        const scrollName = slot.scrollType ? SCROLLS[slot.scrollType].name.split(' ')[0] + ' ' + SCROLLS[slot.scrollType].name.split(' ')[1] : 'N/A';
                        slotsHTML += `
                            <div style="background: ${bgColor}; padding: 6px; border-radius: 3px; font-size: 11px; text-align: center;">
                                <strong>Slot ${slot.slot}</strong><br>
                                ${slot.unfunded ? status : scrollName + '<br>' + status}
                                ${slot.success ? '<br>+' + slot.attack + ' ATK' : ''}
                            </div>
                        `;
                    });
                    slotsHTML += '</div></div>';
                }

                strategyDiv.innerHTML = `
                    <h3>${strategy.name} ${isBest ? '⭐ (Best Average Attack)' : ''}</h3>
                    <p style="color: #7f8c8d; margin: 5px 0;">${strategy.description}</p>

                    <div class="metrics">
                        <div class="metric">
                            <div class="metric-value">${data.avgAttack.toFixed(1)}</div>
                            <div class="metric-label">Avg Total Attack</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${data.avgDamageAmp.toFixed(2)}%</div>
                            <div class="metric-label">Avg Damage Amp</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${data.avgSuccess.toFixed(1)}</div>
                            <div class="metric-label">Avg Successful Slots</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${(10 - data.avgSuccess).toFixed(1)}</div>
                            <div class="metric-label">Avg Failed Slots</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${data.avgResets.toFixed(1)}</div>
                            <div class="metric-label">Avg Resets</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${data.avgTraceUsed.toFixed(0)}</div>
                            <div class="metric-label">Avg Trace Used</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${efficiency.toFixed(3)}</div>
                            <div class="metric-label">ATK per Trace</div>
                        </div>
                    </div>

                    <div style="margin-top: 15px;">
                        <strong>Attack Distribution (across ${numSimulations.toLocaleString()} simulations):</strong>
                        <div style="background: white; padding: 8px; margin-top: 5px; border-radius: 4px; font-family: monospace; font-size: 13px;">
                            10th: ${p10} | 50th (median): ${p50} | 90th: ${p90}
                        </div>
                    </div>

                    ${slotsHTML}
                `;

                container.appendChild(strategyDiv);
            }
        }
    </script>
</body>
</html>
